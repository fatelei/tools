{
  "name": "tasks-queue",
  "description": "Put tasks in a queue and process them one by one, but not too often",
  "version": "0.0.2",
  "homepage": "https://github.com/tutukin/tasks-queue",
  "author": {
    "name": "Andrei V. Toutoukine",
    "email": "tut@isuct.ru"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/tutukin/tasks-queue.git"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "/blob/master/LICENSE-MIT"
    }
  ],
  "main": "lib/tasks-queue",
  "engines": {
    "node": ">= 0.8.0"
  },
  "scripts": {
    "test": "grunt test"
  },
  "devDependencies": {
    "grunt-contrib-jshint": "~0.1.1",
    "grunt-simple-mocha": "~0.3.2",
    "grunt-contrib-watch": "~0.2.0",
    "grunt": "~0.4.1",
    "expect.js": "0.2.x",
    "sinon": "1.6.x",
    "mock": "0.1.x"
  },
  "keywords": [
    "queue",
    "scheduler"
  ],
  "readme": "# tasks-queue\n\nPut tasks in a queue and process them one by one, but not too often.\n\n## Getting Started\n\n### Installation\n\n    npm install tasks-queue\n\n### Synopsis\n\n    var TasksQueue = require('tasks-queue'),\n        q = new TasksQueue();\n    \n    // The queue should not execute more than one task in 500 ms.\n    q.setMinTime(500);\n    q.setVar('value',0);\n    \n    q.pushTask('sample task',{n:5});\n    q.pushTask('sample task',{n:32});\n    q.pushTask('sample task',{n:98});\n    q.pushTask('sample task',{n:33});\n    \n    q.on('sample task', process);\n    q.on('stop', logResults);\n    \n    q.execute();\n    \n    function process(jinn,data) {\n        var q = jinn.getQueue();\n        q.setVar('value', data.n + q.getVar('value'));\n        jinn.done(); // important!\n    }\n    \n    function logResults(jinn) {\n        console.log( jinn.getQueue().getVar('value') );\n    }\n\n## API\n\nTasksQueue class inherits from [EventEmitter](http://nodejs.org/api/events.html).\n\n### new TasksQueue([options])\n\nCreate a new queue object. `options` object may be passed to the constructor.\n\n#### options.autostop\n\nDefault: `true`. Emit a 'stop' event when the queue is empty. If explicitly\nset to `false` the queue does not emit 'stop' event. It waits for `minTime`\nand checks if there are some tasks to do. \n\nSee also `autostop()` and `noautostop()`\n\n### pushTask(taskType,taskData)\n\nAppend a task to the tail of the queue\n\n`taskType` is a string, that is used to distinguish the different\nclasses of tasks. `taskData` is any data that given task needs.\n\n### unshiftTask(taskType,taskData)\n\nPrepend the task to the head of the queue.\nArguments are the same as in `pushTask`. \n\n### taskType events\n\n`taskType` argument to `pushTask` and `unshiftTask` is used to\ndistinguish between the different calsses of tasks. The queue\nemits an event named after the `taskType` of the current task at\nthe head of the queue.\n\nFor example, the user has two types of tasks: 'simple', and 'not so simple'.\nThen the code may look like this:\n\n    queue.pushTask('simple','some data');\n    // ...\n    queue.pushTask('not so simple',{/*...*/});\n    // ...\n    queue.on('simple',function(jinn,taskData) {/*...*/; jinn.done(); });\n    queue.on('not so simple', function(jinn,taskData) {/*...*/; jinn.done(); });\n\nThe arguments passed to the event listeners are an instance of `Jinn` and `taskData`.\n\n### 'stop' event\n\nWhen there is no more tasks in the queue it emits 'stop' event, passing an\ninstance of `Jinn` to the listeners.\n\n    queue.on('stop',function(jinn) { /* ... */ });\n\n### length()\n\nReturn the number of tasks the queue keeps.\n\n### setVar(name,object)\n\nSet the value of the variable named `name` to the `object`\n\n### getVar(name)\n\nReturn the value of the variable named `name`\n\n### setMinTime(minTime)\n\nSet the minimal time interval between the tasks' executions to `minTime` milliseconds.\n\n### getMinTime()\n\nReturn the minimal time interval between the tasks' executions.\n\n### execute()\n\nExecute the tasks in the queue.\n\nWhen the queue is not empty take the task from top and emit a `taskType` event.\nListeners are called with an instance of `Jinn` as the first argument and\nthe `taskData` as the second one. `taskType` and `taskData` are the arguments passed\nto `pushTask()` or `unshiftTask()` methods. `Jinn` class is discussed below.\n\nEvery task listener should call `jinn.done()` method to specify the end of task execution\n(see `taskDone()` method). This allows the queue to continue execution.\n\nWhat happens when the queue is empty depends on the `autostop` option passed to the\nconstructor. By default `autostop` is `true` and the queue immediately emits a 'stop'\nevent. If `autostop` option was explicitly set to `false` the queue starts\na timer that waits for `minTime` milliseconds and calls `execute()` again.\n\n### getTask(n)\n\nUsually you don't need this method.\n\nReturn an instance of Task corresponding to `n`-th task in the queue.\n`n` is between 0 and `queue.length()-1`.\n\n### taskDone()\n\nUsually you don't need this method.\n\nThis method is called when a user calls `Jinn.done()` from the `taskType` event listener.\nIf `minTime` or more milliseconds was passed since the last `taskType` event was emitted\nit calls `execute()`. \n\nIf the method is called before `minTime` is passed, then it returns immediately. `execute()`\nhowever will be magically called again when the `minTime` will pass. \n\n### isTaskRunning()\n\nUsually you don't need this method.\n\nReturns true if the task is executed and `Jinn.done()` was not called yet\n\n### shouldWaitMinTime()\n\nUsually you don't need this method.\n\nReturns true if the time passed since the beginning of the current task\nis less than `minTime` milliseconds.\n\n### shouldAutostop()\n\nReturns `false` if autostop is not allowed. See `TasksQueue` constructor\ndescription.\n\n### autostop()\n\nYou may need this method if `autostop: false` option was used. It simply\nmakes the queue to autostop. I.e. when the `execute()` method finds that\nthe queue is empty, it immediately emits 'stop' event. \n\n### noautostop()\n\nThe opposite of `autostop()`. Remember, if you call this method after\nthe queue emitted 'stop' event, you should manually call `execute()`\nagain to start execution.\n\n## Jinn\n\nThis class provides useful methods to the event listeners, bound to the\nTasksQueue events. An instance of `Jinn` is passed as the first argument\nto the listeners. Inherits from the EventEmitter.\n\n### getQueue()\n\nReturn an instance of queue which emitted an event.\n\n### getType()\n\nReturn event name: 'stop' or `taskType`\n\n### getData()\n\nReturn `taskData` for `taskType` event\n\n### done()\n\nEmit 'done' event. In the case of `taskType` event\nTasksQueue binds to this event a listener that\ncalls `TasksQueue.taskDone()`.\n\n## Task\n\nThis is an internal class that represents a task. The instance\nof Task is returned by `TasksQueue.getTask(n)` method.\n\n### setData(data)\n\nSet the data for a task.\n\n### getData()\n\nReturn the data for a task.\n\n### setType(taskType)\n\nSet type of a task.\n\n### getType()\n\nReturn a taskType of a task.\n\n## Examples\n\n* See examples directory,\n* see [request-queue](https://github.com/tutukin/request-queue) project\n\n## Contributing\n\nIn lieu of a formal styleguide, take care to maintain the existing\ncoding style. Add unit tests for any new or changed functionality.\nLint and test your code using Grunt.\n\n## Release History\n\n* April 11, 2013. V. 0.0.2. \nAdded 'autostop' feature control.\n\n* April 1, 2013. V. 0.0.1.\nBasic functionality\n\nLicense\n\nCopyright (c) 2013 Andrei V. Toutoukine\nLicensed under the MIT license.\n\n",
  "readmeFilename": "README.md",
  "_id": "tasks-queue@0.0.2",
  "dist": {
    "shasum": "bad59a310808eb5729e48ab986960bc8adcd7fea"
  },
  "_from": "tasks-queue@",
  "_resolved": "https://registry.npmjs.org/tasks-queue/-/tasks-queue-0.0.2.tgz"
}
